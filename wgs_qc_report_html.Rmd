---
title: "WGS Quality Control Report"
output: html_document
mainfont: Helvetica
papersize: a4
---

```{css, echo=FALSE}
.main-container {
  max-width: 1300px !important;
  margin-left: auto;
  margin-right: auto;
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.pos = 'H')
```

```{r load library, echo = FALSE, warning = FALSE, message = FALSE}
library(tidyverse)
library(knitr)
library(readxl)
library(dplyr)
library(kableExtra)
library(RColorBrewer)
library(scales)
library(readr)
library(writexl)
library(conflicted)
library(stringr)
library(ggplot2)
library(DT)
library(htmltools)  # <-- needed for tags

conflicts_prefer(openxlsx::write.xlsx)
conflicts_prefer(dplyr::filter)
```



```{r load-data, echo = FALSE, warning = FALSE, message = FALSE}
# --- rename species column to wgs_org ---
wgs_df <- wgs_result_df %>% rename(wgs_id = species)

# --- complete wgs_org  ---
wgs_df$wgs_id <- ifelse(wgs_df$wgs_id == "Acinetobacter", "Acinetobacter baumannii", 
                         ifelse(wgs_df$wgs_id == "Escherichia", "Escherichia coli", wgs_df$wgs_id))

# --- load organism code reference file ---
org_df <- read_xlsx("data_files/whonet_codes_2024.xlsx", "ORGANISM") %>%
  select(ORG_ARS, ORGANISM_name) %>% 
  rename(wgs_id = ORGANISM_name)

# --- merge dataframes ---
wgs_df <- merge(wgs_df, org_df, by = "wgs_id", all.x = TRUE)


# --- rename ORG_ARS column to ORG ---
wgs_df <- wgs_df %>% rename(org_code = ORG_ARS)

# --- Clean organism name ---
wgs_df <- wgs_df %>%
  mutate(
    org_code_clean = case_when(
      wgs_id == "Escherichia/Shigella" ~ "eco",
      str_detect(wgs_id, "Salmonella enterica") ~ "sat",
      str_detect(wgs_id, "Salmonella") ~ "sal",
      str_detect(wgs_id, "Streptococcus pseudopneumoniae") ~ "spn",
      str_detect(wgs_id, "Streptococcus pyogenes") ~ "spy",
      str_detect(wgs_id, "Streptococcus oralis") ~ "sol",
      str_detect(wgs_id, "Streptococcus") ~ "spn",
      str_detect(wgs_id, "Staphylococcus epidermidis") ~ "sep",
      str_detect(wgs_id, "Staphylococcus") ~ "sau",
      str_detect(wgs_id, "Shigella") ~ "shi",
      str_detect(wgs_id, "Vibrio") ~ "vic",
      str_detect(wgs_id, "Klebsiella") ~ "kpn",
      str_detect(wgs_id, "Raoultella planticola") ~ "kpn",
      str_detect(wgs_id, "Pseudomonas") ~ "pae",
      str_detect(wgs_id, "Acinetobacter") ~ "aba",
      str_detect(wgs_id, "Burkholderia") ~ "pce",
      str_detect(wgs_id, "Serratia marcescens") ~ "sma",
      TRUE ~ org_code
    )
  )

```




```{r sample-sheet, echo = FALSE, warning = FALSE, message = FALSE}
# --- Read samplesheet ---
wgs_samplesheet <- read_csv(paste0("data_files/", get_samplesheet, ".csv")) 

# --- Get experiment name ---
WGS_exp_name <- unique(wgs_samplesheet$`experiment name`)

# --- remove special characters in batch name ---
batch_name_clean <- gsub("[[:punct:]]", "", batch_code)

# --- Modify dataframe ---
wgs_samplesheet <- wgs_samplesheet%>%
  rename_with(tolower) %>%              # lowercase column names
  mutate(
    sample_id = toupper(sample_id),     # uppercase sample_id
    sample_id = str_replace_all(sample_id, "-", "_"),  # replace "-" with "_"
    batch_name_clean = str_remove_all(batch_code, "[[:punct:]]"), # clean batch code
    sample_id = paste(sample_id, batch_name_clean, sep = "_")      # append batch
  ) %>%
  select(sample_id, description)  # optional: remove helper column

```


**Batch Name: `r batch_code`**

**Experiment Name: `r WGS_exp_name`**



\fontsize{7}{8}
\selectfont
\captionsetup[table]{labelformat=empty}
\renewcommand{\arraystretch}{1.2}

$\\$

```{r qc-listing, echo = FALSE, warning = FALSE, message = FALSE}
# --- Subset wgs_df ---
wgs_id_df <- subset(wgs_df, select = c('sample_id','wgs_id'))


# --- paste batch number to arsrl result sample_id ---
arsrl_id_df <- arsrl_result_df %>%
  mutate(sample_id = paste(sample_id, batch_name_clean, sep = "_"))


# --- Add isolate numbers ---
arsrl_id_df$iso_num <- seq_len(nrow(arsrl_id_df))


# --- merge arsrl result  and samplesheet ---
arsrl_result_merge <- merge(unique(arsrl_id_df), unique(wgs_samplesheet), by = "sample_id", all.x= TRUE)


# --- Merge WGS and ARSRL results ---
qc_listing_df <- merge(
  unique(wgs_id_df), 
  unique(arsrl_result_merge), 
  by = "sample_id", 
  all.x = TRUE
)

# Preserve original WGS order
qc_listing_df <- qc_listing_df[match(wgs_result_df$sample_id, qc_listing_df$sample_id), ]

# Fill missing WGS IDs
qc_listing_df$wgs_id[is.na(qc_listing_df$wgs_id)] <- "Not Identified"

# --- Handle samples with no WGS results ---
wgs_no_result <- wgs_samplesheet[!wgs_samplesheet$sample_id %in% wgs_df$sample_id, ]

if (nrow(wgs_no_result) > 0) {
  qc_listing_df$description <- ifelse(
    is.na(qc_listing_df$description),
    wgs_samplesheet_subset$description[match(
      paste0(wgs_no_result$sample_id, "_", batch_name_clean),
      wgs_samplesheet_subset$sample_id
    )],
    qc_listing_df$description
  )
}


# --- Concordance check ---
qc_listing_df <- qc_listing_df %>%
  rowwise() %>%
  mutate(
    Genus = strsplit(as.character(arsrl_org), " ")[[1]][1],
    concordant = ifelse(wgs_id != "Not Identified", grepl(Genus, wgs_id), TRUE),
    concordant = ifelse(arsrl_org == "No Referred Data", TRUE, concordant)
  ) %>%
  ungroup()

# Append (x) to non-concordant ARSRL results
qc_listing_df$arsrl_org <- ifelse(
  qc_listing_df$concordant,
  qc_listing_df$arsrl_org,
  paste0(qc_listing_df$arsrl_org, " (x)")
)

# Match concordance back to WGS df
wgs_df$concordant <- qc_listing_df$concordant[match(wgs_df$sample_id, qc_listing_df$sample_id)]


# --- Modify and Filter Bactscout dataframe ---
df_bactscout_mod <- df_bactscout %>%
  mutate(name = gsub("-", "_", name)) %>%
  filter(name %in% sample_name)



# --- Identify failed WGS sample names ---
raw_read_failed <- df_bactscout_mod$name[df_bactscout_mod$a_final_status == "FAILED"]

  
# --- Get row numbers in qc_listing_df where sample_id matches any failed sample ---
failure_color <- which(qc_listing_df$sample_id %in% raw_read_failed)


# --- Clean up ---
qc_listing_df <- qc_listing_df %>%
  select(-Genus, -concordant) %>%
  mutate(sample_id = sub("(.*)_[^_]*$", "\\1", sample_id))


# Rename and reorder columns
colnames(qc_listing_df) <- c("Sample ID", "WGS", "ARSRL", "Isolate No.", "Description")
qc_listing_df <- qc_listing_df[, c("Isolate No.", "Sample ID", "Description", "ARSRL", "WGS")]

# --- Generate formatted table ---
# --- Generate Legend HTML ---
qc_legend <- HTML(paste0(
  "<strong>Legend: </strong>",
  "PASS | ",
  '<span style="background-color: #FD7979; padding: 2px 6px; border-radius: 4px; font-weight: bold;">FAILURE</span> | ',
  "(x) - NON-CONCORDANT"
))

# --- Generate Interactive Table ---
datatable(qc_listing_df,
          extensions = 'Buttons',
          escape = FALSE,
          rownames = FALSE,
          class = 'cell-border stripe',
          caption = tags$caption(style = 'caption-side: bottom; text-align: left;', qc_legend),
          options = list(
            pageLength = 10,
            scrollX = TRUE,
            dom = 'lBfrtip',
            #dom = 'lfrtip',
            buttons = c('copy', 'csv', 'excel', 'print'),
            # Header alignment
            # --- Custom Header Styling ---
            initComplete = JS(
              "function(settings, json) {",
              "$(this.api().table().header()).css({",
              "  'background-color': '#D4D4D4',",
              "  'color': 'black',",
              "  'text-align': 'center'", # Centers the header text block
              "});",
              # This secondary selector ensures the specific header cells are centered
              "$(this.api().table().header()).find('th').css('text-align', 'center');",
             "}"
             )
            )
          ) %>%
  # Apply formatting to specific columns (analogous to column_spec)
  formatStyle(
    columns = c(4, 5), # Species columns
    fontStyle = 'italic'
  ) %>%
  # Apply Row Highlighting (analogous to row_spec)
  formatStyle(
    columns = names(qc_listing_df), # Apply to all columns to highlight the whole row
    target = 'row',
    backgroundColor = styleRow(failure_color, '#FD7979')
  ) %>%
  # Center align all columns
  formatStyle(
    columns = names(qc_listing_df),
    textAlign = 'center'
  )
```



```{r low-reads, echo=FALSE, message=FALSE, warning=FALSE,results='asis'}
# Filter dataframe based on the sample_id not present in the WGS samplesheet
wgs_lowreads <- wgs_samplesheet[!(wgs_samplesheet$sample_id %in% wgs_df$sample_id), ]
wgs_lowreads <- subset(wgs_lowreads, select = c('sample_id','description'))

if (nrow(wgs_lowreads) != 0) {
  lowreads_table <- wgs_lowreads
  lowreads_table$remarks <- "low read count"
  
  # Remove batch name in sample_id
  lowreads_table$sample_id <- sub("(.*)_[^_]*$", "\\1", lowreads_table$sample_id)
  colnames(lowreads_table) <- c('Sample ID', 'Description', 'Remarks') 

  # --- Create Custom Header for "add_header_above" equivalent ---
  # This creates a spanning header row across all 3 columns
  sketch <- htmltools::withTags(table(
    class = 'display',
    thead(
      tr(
        th(colspan = 3, style = "text-align: left; border-bottom: 1px solid #111;", "Sample excluded in the analysis")
      ),
      tr(
        lapply(colnames(lowreads_table), th, style = "text-align: center;")
      )
    )
  ))

  # --- Render Interactive Table ---
  datatable(lowreads_table,
            container = sketch,        # Uses the custom header defined above
            rownames = FALSE,
            class = 'cell-border stripe',
            options = list(
              dom = 'Bfrtip',               # Only show the table (no search/pagination) as it's a summary
              scrollX = TRUE,
              columnDefs = list(
                list(className = 'dt-center', targets = "_all"), # Center all body cells
                list(width = '150px', targets = 0),              # Approx 3cm
                list(width = '150px', targets = 1),              # Approx 3cm
                list(width = '350px', targets = 2)               # Approx 7cm
              ),
              initComplete = JS(
                "function(settings, json) {",
                "$(this.api().table().header()).find('tr:eq(1) th').css({",
                "  'background-color': '#D4D4D4',",
                "  'color': 'black'",
                "  'text-align': 'center'", # Centers the header text block
                "});",
                "}"
                )
              )
  )
  }


```


$\\$


### **RAW READS QC**


```{r bactscout-df-value, echo = FALSE, warning = FALSE, message = FALSE}
# --- Create new column to check final status with warning status and list column indices with failed results ---
bactscout_df_result <- df_bactscout_mod %>%
  select(name, species,contamination = contamination_message,`Coverage (Qualibact)` = coverage_estimate_qualibact_status, `Duplication Rate` = duplication_status, 
        `GC Content` = gc_content_status, `MLST (ST)` = mlst_status, `Read Length` = read_length_status, `Read Q30` = read_q30_status, a_final_status)

bactscout_df_result$failed_idx <- apply(bactscout_df_result, 1, function(row) {
  if (row["a_final_status"] == "FAILED") {
    # Get indices of columns with FAILED
    failed_cols <- which(row[-c(1,2,10)] == "FAILED") # exclude name and species
    # Adjust index to match original dataframe
    failed_cols <- failed_cols + 3
    paste(failed_cols, collapse = ", ")
  } else {
    "" 
  }
})


bactscout_df_result$failed_cols <- apply(bactscout_df_result, 1, function(row) {
  if (row["a_final_status"] == "FAILED") {
    warning_cols <- names(row)[which(row[-c(1,2,10)] == "FAILED") + 2] # adjust for original df
    if (length(warning_cols) == 0) {
      ""
    } else {
      paste(warning_cols, collapse = ", ")
    }

  } else {
    "" 
  }
})



# --- List sample without bactscout result ---
no_bactscout_result <- setdiff(sample_name, df_bactscout_mod$name)

# --- remove text after last underscore ---
no_bactscout_result <- sub("_[^_]*$", "", no_bactscout_result)


# --- Modify dataframe ---
bactscout_df_value <- df_bactscout_mod %>%
  select(name, species, species_abundance, coverage_estimate_qualibact, duplication_rate, 
         gc_content, mlst_st, read1_mean_length, read2_mean_length, read_q30_rate, a_final_status) %>%
  rename(sample_id = name) %>%
  mutate(read_length = paste0(read1_mean_length, " - ", read2_mean_length)) %>%
  select(-read1_mean_length, -read2_mean_length) %>%
  relocate(read_length, .before = "read_q30_rate")

# Change MLST ST column NUll value to Blank
bactscout_df_value$mlst_st <- lapply(bactscout_df_value$mlst_st, function(x) {
  if (is.null(x)) "" else x
})



# --- Get Isolate number by merging ---
bactscout_df_merge <- merge(bactscout_df_value, arsrl_id_df, by ="sample_id")

# --- Modify dataframe ---
bactscout_df_merge <- bactscout_df_merge %>%
  mutate(sample_id = sub("(.*)_[^_]*$", "\\1", sample_id)) %>%
  select(-arsrl_org) %>%
  relocate(iso_num, .before = "sample_id") 



# Rename columns
colnames(bactscout_df_merge) <- c("Isolate No.","Sample ID", "Species", "Species Abundance", "Coverage (Qualibact)", "Duplication Rate",
                                  "GC Content", "MLST (ST)", "Read Length", "Read Q30", "Final Status")

# --- 1. Loop for Specific Failure Cells (Keep this logic) ---
# We keep using cell_spec here because these errors happen in different columns per row
for (i in 1:nrow(bactscout_df_result)) {
  if (!is.na(bactscout_df_result$failed_idx[i]) && nzchar(bactscout_df_result$failed_idx[i])) {
    indices <- tryCatch({
      as.numeric(trimws(unlist(strsplit(bactscout_df_result$failed_idx[i], ","))))
    }, error = function(e) numeric(0))
    
    indices <- indices[!is.na(indices) & indices > 0]
    
    for (col in indices) {
      display_col <- col
      if (display_col <= ncol(bactscout_df_merge)) {
        bactscout_df_merge[i, display_col] <- cell_spec(
            bactscout_df_merge[i, display_col], 
            format = "html", 
            background = "#D2042D", 
            color = "white", 
            bold = TRUE
        )
      }
    }
  }
}

# NOTE: We REMOVED the `mutate` block for "Final Status". 
# We will let DT handle the coloring in the final step.

# --- 2. Generate Interactive Table with formatStyle ---

# Define Legend
legend_html <- HTML(paste0(
  "<strong>Legend: </strong>",
  '<span style="background-color: #006b54; color: white; padding: 2px 6px; border-radius: 4px;">PASSED</span> | ',
  '<span style="background-color: #ffd858; padding: 2px 6px; border-radius: 4px;">WARNING</span> | ',
  '<span style="background-color: #D2042D; color: white; padding: 2px 6px; border-radius: 4px;">FAILED</span>'
))

# Render Datatable
datatable(bactscout_df_merge,
          extensions = 'Buttons',
          escape = FALSE, # Allows the red cells from the loop to render
          rownames = FALSE,
          class = 'cell-border stripe',
          caption = tags$caption(style = 'caption-side: bottom; text-align: left;', legend_html),
          options = list(
            pageLength = 15,
            scrollX = TRUE,
            #dom = 'Bfrtip',
            dom = 'lBfrtip',
            #dom = 'lfrtip',
            buttons = c('copy', 'csv', 'excel', 'print'),
            # --- Custom Header Styling ---
            initComplete = JS(
              "function(settings, json) {",
              "$(this.api().table().header()).css({",
              "  'background-color': '#D4D4D4',",
              "  'color': 'black',",
              "  'text-align': 'center'", # Centers the header text block
              "});",
              # This secondary selector ensures the specific header cells are centered
              "$(this.api().table().header()).find('th').css('text-align', 'center');",
              "}"
            )
          )
          ) %>%
  # --- 3. Apply Full Cell Background Colors Here ---
  formatStyle(
    'Final Status',
    target = 'cell', # Targets the whole box, not just the text
    backgroundColor = styleEqual(
      c('PASSED', 'WARNING', 'FAILED'), 
      c('#006b54', '#ffd858', '#D2042D')
    ),
    color = styleEqual(
      c('PASSED', 'WARNING', 'FAILED'), 
      c('white', 'black', 'white') # Adjust text color for readability
    ),
    fontWeight = 'bold'
  ) %>%
  # Center align all columns
  formatStyle(
    columns = names(bactscout_df_merge),
    textAlign = 'center'
  ) %>% # Apply formatting to specific columns (analogous to column_spec)
  formatStyle(
    columns = 3, # Species columns
    fontStyle = 'italic'
  )

  
```


```{r no-bactscout-result, echo=FALSE, message=FALSE, warning=FALSE}
if(length(no_bactscout_result) != 0){
  # Convert the vector to a single comma-separated string
  no_bactscout_id <- paste(no_bactscout_result, collapse = ", ")
  
  # Create new dataframe
  df_no_bactscout <- data.frame(
    sample_id = no_bactscout_id, 
    Remarks = "No Raw Reads Data"
  )
  
  colnames(df_no_bactscout) <- c('Sample ID', 'Remarks')
  
  # Render Interactive Table
  datatable(df_no_bactscout,
    #extensions = 'Buttons',
    rownames = FALSE,
    class = 'cell-border stripe',
    options = list(
      dom = 't', # Buttons, Length, filter, processing, table, info, pagination
      buttons = c('copy', 'csv', 'excel'),
      lengthMenu = list(c(5, 10, 25, -1), c('5', '10', '25', 'All')),
      pageLength = 10,
      scrollX = TRUE, # Important for long comma-separated lists
      columnDefs = list(
        list(targets = 0, className = 'dt-left'),  # Sample IDs left aligned
        list(targets = 1, className = 'dt-center') # Remarks center aligned
      ),
      initComplete = JS(
        "function(settings, json) {",
        "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
        "$(this.api().table().header()).find('th').css('text-align', 'center');",
        "}"
      )
    )
  )
}

```


$\color{red}{\normalsize\textbf{SUMMARY OF RESULT:}}$


```{r summary-table ,echo=FALSE, message=FALSE, warning=FALSE}
summary_raw_df <- bind_rows(
  # Non-concordant WGS
  wgs_df %>%
    filter(concordant == "FALSE") %>%
    transmute(sample_id, failed_conditions = "Non-concordant result"),

  # Failed raw reads (from BactScout)
  bactscout_df_result %>%
    filter(failed_cols != "") %>%
    transmute(sample_id = name,
              failed_conditions = failed_cols),

  # Low read counts (only if exists)
  if (nrow(wgs_lowreads) > 0)
    wgs_lowreads %>%
      transmute(sample_id,
                failed_conditions = "Low read counts")
) %>%
  mutate(sample_id = sub("(.*)_[^_]*$", "\\1", sample_id)) %>%   # ðŸ‘ˆ normalize IDs
  group_by(sample_id) %>%
  summarise(
    failed_conditions = paste(unique(failed_conditions), collapse = ", "),
    .groups = "drop"
  )



if (nrow(summary_raw_df) != 0) {
  colnames(summary_raw_df) <- c('Sample ID','Reason - Failed Metrics')
  
  # Render Interactive Table
  datatable(summary_raw_df,
    rownames = FALSE,
    class = 'cell-border stripe',
    options = list(
      dom = 't', # Buttons, Length, filter, processing, table, info, pagination
      lengthMenu = list(c(5, 10, 25, -1), c('5', '10', '25', 'All')),
      pageLength = 10,
      scrollX = TRUE, # Important for long comma-separated lists
      columnDefs = list(
        list(targets = 0, className = 'dt-left'),  # Sample IDs left aligned
        list(targets = 1, className = 'dt-center') # Remarks center aligned
      ),
      initComplete = JS(
        "function(settings, json) {",
        "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
        "$(this.api().table().header()).find('th').css('text-align', 'center');",
        "}"
      )
    )
  )
  
  
  }



```



$\\$
$\\$


### **ASSEMBLY QC**


```{r assembly-qc, echo = FALSE, warning = FALSE, message = FALSE}
assembly_qc <- merge(wgs_df, arsrl_id_df, by = "sample_id")

# --- Read samplesheet ---
qualibact_data <- read_csv("data_files/qualibact_filtered_metrics.csv") %>%
  mutate(species = gsub("_", " ", species))

# --- Prepare reference table: only species present in assembly_qc ---
qualibact_ref <- qualibact_data %>%
  filter(species %in% assembly_qc$wgs_id) %>%
  mutate(metric_clean = str_to_lower(metric))


# --- Map qualibact metrics to assembly_qc column names ---
metric_map <- c(
  "completeness"             = "completeness",
  "contamination"            = "contamination",
  "total_coding_sequences"   = "total_coding_sequences",
  "genome_size"              = "genome_size",
  "gc_content"               = "gc_content",
  "n50"                      = "n50_contig_length",
  "no_of_contigs"            = "total_contig"
)

# --- QC check function ---
check_bounds <- function(value, lower, upper) {
  case_when(
    !is.na(lower) & value < lower ~ "FAILED",
    !is.na(upper) & value > upper ~ "FAILED",
    TRUE                          ~ "PASSED"
  )
}

# --- Apply QC checks ---
assembly_qc_checked <- assembly_qc

for (m in names(metric_map)) {

  ref <- qualibact_ref %>%
    filter(metric_clean == m) %>%
    select(species, lower_bounds, upper_bounds)

  assembly_qc_checked <- assembly_qc_checked %>%
    left_join(ref, by = c("wgs_id" = "species")) %>%
    mutate(
      !!paste0(metric_map[m], "_qc") :=
        check_bounds(.data[[metric_map[m]]], lower_bounds, upper_bounds)
    ) %>%
    select(-lower_bounds, -upper_bounds)
}



# --- List all FAILED QC ---
assembly_qc_checked <- assembly_qc_checked %>%
  rowwise() %>%
  mutate(
    condition_checks = list(c(
      "Completeness" = completeness_qc == "PASSED",
      "Contamination" = contamination_qc == "PASSED",
      "Total Coding Sequences" = total_coding_sequences_qc == "PASSED",
      "Genome Size" = genome_size_qc == "PASSED",
      "GC Content" = gc_content_qc == "PASSED",
      "N50" = n50_contig_length_qc == "PASSED",
      "Total Contigs" = total_contig_qc == "PASSED"
    )),
    # Set result to FALSE if any condition is FALSE or NA
    result = all(unlist(condition_checks), na.rm = FALSE),
    
    # Only list failed conditions (FALSE), remove NA
    failed_conditions = {
      cond_values <- unlist(condition_checks)
      failed <- names(cond_values[!is.na(cond_values) & cond_values == FALSE])
      if (length(failed) == 0) NA_character_ else paste(failed, collapse = ", ")
    }
  ) %>%
  ungroup()



# Get raw reads result from bactscout_df_result
assembly_qc_checked$raw_reads_result <- bactscout_df_result$a_final_status[bactscout_df_result$name == assembly_qc_checked$sample_id]

# condition assembly qc result
assembly_qc_checked <- assembly_qc_checked %>%
  mutate(assembly_result = ifelse(result == TRUE, "PASSED", "FAILED"))

file_name <- paste0("data_files/assembly_qc_checked.xlsx")
write_xlsx(assembly_qc_checked, file_name)

```




```{r aasembly-qc-graph, echo = FALSE, warning = FALSE, message = FALSE}
# --- Create new column to check final status with warning status and list column indices with failed results ---
assembly_qc_result <- assembly_qc_checked %>%
  select(iso_num, sample_id, wgs_id, completeness_qc, contamination_qc, total_coding_sequences_qc, 
        genome_size_qc, gc_content_qc, n50_contig_length_qc, total_contig_qc)

assembly_qc_result$failed_idx <- apply(assembly_qc_result, 1, function(row) {
  failed_cols <- which(row[-c(1:3)] == "FAILED") # exclude name and species
    # Adjust index to match original dataframe
    failed_cols <- failed_cols + 3
    paste(failed_cols, collapse = ", ")
})


# --- List sample without assembly result ---
no_assembly_result <- setdiff(sample_name, assembly_qc_result$sample_id)

# --- remove text after last underscore ---
no_assembly_result <- sub("_[^_]*$", "", no_assembly_result)


# --- Modify dataframe ---
assembly_qc_value <- assembly_qc_checked %>%
  select(iso_num, sample_id, wgs_id, completeness, contamination, total_coding_sequences, 
        genome_size, gc_content, n50_contig_length, total_contig, raw_reads_result, assembly_result) %>%
  mutate(sample_id = sub("(.*)_[^_]*$", "\\1", sample_id))


# Create a conversion function to convert Basepairs to MEgabasepairs
bp_to_mb <- function(bp) {
  x <- bp / 1e6
  x <- format(round(x, 2), nsmall = 2)
  x <- paste0(x, " Mb")
  return(x)
}

assembly_qc_value$genome_size <- bp_to_mb(assembly_qc_value$genome_size)


# Rename and reorder columns
colnames(assembly_qc_value) <- c("Isolate No.","Sample ID", "WGS ID", "Completeness", "Contamination", "Total Coding Sequences",
                                 "Genome Size", "GC Content", "N50", "Total Contig", "Raw Reads Result", "Assembly Result")

# Change Assembly Result based on Raw Reads Result
assembly_qc_value <- assembly_qc_value %>%
  mutate(`Assembly Result` = ifelse(`Raw Reads Result` == 'FAILED', "FAILED", `Assembly Result`))

```




```{r assembly-df-html, echo = FALSE, warning = FALSE, message = FALSE}
# --- 1. Prepare Data ---
# Convert everything to character to support the HTML injected by the loop
assembly_qc_value[] <- lapply(assembly_qc_value, as.character)

# --- 2. Loop for Specific Cell Failures (Failed Indices) ---
for (i in 1:nrow(assembly_qc_result)) {
  if (!is.na(assembly_qc_result$failed_idx[i]) && nzchar(assembly_qc_result$failed_idx[i])) {
    
    indices <- tryCatch({
      as.numeric(trimws(unlist(strsplit(assembly_qc_result$failed_idx[i], ","))))
    }, error = function(e) numeric(0))
    
    indices <- indices[!is.na(indices) & indices > 0]
    
    for (col in indices) {
      if (col <= ncol(assembly_qc_value)) {
        assembly_qc_value[i, col] <- cell_spec(
          assembly_qc_value[i, col], 
          format = "html", 
          background = "#D2042D", 
          color = "white", 
          bold = TRUE
        )
      }
    }
  }
}

# --- 3. Generate Interactive Table ---

legend_html <- HTML(paste0(
  "<strong>Legend: </strong>",
  '<span style="background-color: #006b54; color: white; padding: 2px 6px; border-radius: 4px;">PASSED</span> | ',
  '<span style="background-color: #ffd858; padding: 2px 6px; border-radius: 4px;">WARNING</span> | ',
  '<span style="background-color: #D2042D; color: white; padding: 2px 6px; border-radius: 4px;">FAILED</span>'
))

datatable(assembly_qc_value,
          extensions = 'Buttons',
          escape = FALSE, 
          rownames = FALSE,
          class = 'cell-border stripe',
          caption = tags$caption(style = 'caption-side: bottom; text-align: left;', legend_html),
          options = list(
            dom = 'lBfrtip',
            buttons = c('copy', 'csv', 'excel', 'print'),
            pageLength = 10,
            lengthMenu = list(c(10, 25, 50, -1), c('10', '25', '50', 'All')),
            scrollX = TRUE,
            # --- Centering the Body Data ---
            columnDefs = list(
              list(className = 'dt-center', targets = "_all") # Forces center alignment for all body cells
            ),
            # --- Centering and Styling the Header ---
            initComplete = JS(
              "function(settings, json) {",
              "$(this.api().table().header()).css({",
              "  'background-color': '#D4D4D4',",
              "  'color': 'black'",
              "});",
              # Specifically target the header 'th' elements for centering
              "$(this.api().table().header()).find('th').css('text-align', 'center');",
              "}"
            )
          )
        ) %>%
  # --- 4. Apply Cell Background Colors ---
  formatStyle(
    c('Raw Reads Result', 'Assembly Result'), 
    target = 'cell',
    backgroundColor = styleEqual(
      c('PASSED', 'WARNING', 'FAILED'), 
      c('#006b54', '#ffd858', '#D2042D')
    ),
    color = styleEqual(
      c('PASSED', 'WARNING', 'FAILED'), 
      c('white', 'black', 'white')
    ),
    fontWeight = 'bold',
    textAlign = 'center' # Double-ensures text within these colored cells is centered
  ) %>% # Apply formatting to specific columns (analogous to column_spec)
  formatStyle(
    columns = 3, # Species columns
    fontStyle = 'italic'
  )

```



$\color{red}{\normalsize\textbf{SUMMARY OF RESULT:}}$


```{r assembly-summary-table ,echo=FALSE, message=FALSE, warning=FALSE}
assembly_failed <- assembly_qc_checked %>% filter(!is.na(failed_conditions))

if (nrow(assembly_failed) !=0) {
  assembly_reco_df <- assembly_failed %>% select(sample_id, failed_conditions) %>%
    mutate(failed_conditions = paste(unique(failed_conditions), collapse = ", ")) %>%
    mutate(sample_id = sub("(.*)_[^_]*$", "\\1", sample_id))
} else {
  sample_id <- ""
  failed_conditions <- "No further action required for this batch."

  
  assembly_reco_df <- data.frame(sample_id,failed_conditions, remarks)
}


colnames(assembly_reco_df) <- c('Sample ID','Reason - Failed Metrics')
  
# Render Interactive Table
datatable(assembly_reco_df,
  #extensions = 'Buttons',
  rownames = FALSE,
  class = 'cell-border stripe',
  options = list(
    dom = 't', # Buttons, Length, filter, processing, table, info, pagination
    buttons = c('copy', 'csv', 'excel'),
    lengthMenu = list(c(5, 10, 25, -1), c('5', '10', '25', 'All')),
    pageLength = 10,
    scrollX = TRUE, # Important for long comma-separated lists
    columnDefs = list(
      list(targets = 0, className = 'dt-left'),  # Sample IDs left aligned
      list(targets = 1, className = 'dt-center') # Remarks center aligned
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
      "$(this.api().table().header()).find('th').css('text-align', 'center');",
      "}"
    )
  )
)


```


$\\$ $\\$ $\\$

### **RESULTS RECOMMENDATION**

```{r overall-recommendation-table ,echo=FALSE, message=FALSE, warning=FALSE}
# --- Process Data (Logic remains the same) ---
overall_reco <- assembly_qc_checked %>% 
  filter(raw_reads_result == "FAILED" | assembly_result == "FAILED") %>%
  select(sample_id, raw_reads_result, assembly_result) %>%
  mutate(sample_id = sub("(.*)_[^_]*$", "\\1", sample_id)) %>%
  group_by(raw_reads_result, assembly_result) %>%
  summarize(sample_id = paste0(sample_id, collapse = ", "), .groups = 'drop')

# Generate Final Result
overall_reco <- overall_reco %>%
  mutate(final_result = case_when(
    raw_reads_result == "PASSED" & assembly_result == "PASSED" ~ "PASSED",
    raw_reads_result == "FAILED" | assembly_result == "FAILED" ~ "FAILED",
    .default = ""
  ))


# --- Conditional Rendering ---
if (nrow(overall_reco) != 0) {
  overall_reco_df <- overall_reco %>%
    relocate(sample_id, .before = raw_reads_result)
  
  colnames(overall_reco_df) <- c("Sample ID", "Raw Reads Result", "Assembly Result", "Final Result")

  datatable(overall_reco_df,
            extensions = 'Buttons',
            rownames = FALSE,
            class = 'cell-border stripe',
            options = list(
             dom = 'lBfrtip',
              buttons = c('copy', 'csv', 'excel', 'print'),
              scrollX = TRUE,
              columnDefs = list(
                list(className = 'dt-center', targets = "_all"),
                list(targets = 0, textAlign = 'left', width = '400px') # Sample IDs left aligned
              ),
              initComplete = JS(
                "function(settings, json) {",
                "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
                "$(this.api().table().header()).find('th').css('text-align', 'center');",
                "}"
              )
            )
          ) %>%
    formatStyle(
      c('Raw Reads Result', 'Assembly Result', 'Final Result'),
      target = 'cell',
      backgroundColor = styleEqual(
        c('PASSED', 'FAILED'), 
        c('#006b54', '#D2042D')
      ),
      color = styleEqual(
        c('PASSED', 'FAILED'), 
        c('white', 'white')
      ),
      fontWeight = 'bold'
    )

} else {
  # --- No Actions Table ---
  overall_reco_df <- data.frame(
    "Sample ID" = "N/A", 
    "Remarks" = "No further action required for this batch."
  )
  
  datatable(overall_reco_df,
    rownames = FALSE,
    options = list(
      dom = 't', # Just the table
      initComplete = JS(
        "function(settings, json) {",
        "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
        "$(this.api().table().header()).find('th').css('text-align', 'center');",
        "}"
      )
    )
  ) %>%
    formatStyle(names(overall_reco_df), textAlign = 'center')
}




```

$\\$ $\\$ $\\$

### MLST RESULTS


```{r mlst_df ,echo=FALSE, message=FALSE, warning=FALSE}
#rename columns
mlst_df_clean <- df_mlst %>%
  rename("sample_id" = 1,
         "species" = 2,
         "MLST" = 3
         ) %>%
  mutate(
    sample_id = sub(".*/(.*)\\.fna$", "\\1", sample_id),
    sample_id = gsub("-", "_", sample_id)
    ) %>%
  filter(str_detect(sample_id, batch_name_clean))


#drop row without species
mlst_df_clean <- subset(mlst_df_clean, mlst_df_clean$species != '-')

#merge wgs_id from wgs_df to mlst_df to set as species value
wgs_species <- subset(wgs_df, select = c("sample_id", "wgs_id"))
mlst_df_clean <- merge(mlst_df_clean,wgs_species,by = "sample_id")

#remove batch name in sample_id
mlst_df_clean$sample_id <- sub("(.*)_[^_]*$", "\\1", mlst_df_clean$sample_id)

#reorder column
mlst_df_clean <- mlst_df_clean %>% 
  relocate(wgs_id, .after = species)

#identify salmonella enterica group
mlst_df_clean$species <- ifelse(mlst_df_clean$wgs_id == 'Salmonella enterica', 'salmonella_enterica', ifelse(mlst_df_clean$wgs_id == 'Salmonella typhoidal','salmonella_typhoidal', mlst_df_clean$species))


#not identified sample
#mlst_df_clean[is.na(mlst_df_clean)] <- 'Not Identified'


#list unique species in the dataframe
species_list <- unique(mlst_df_clean$species)

mlst_df_list = c()

#create multiple dataframe for each species
for(i in species_list) {
  #retain first four columns
  mlst_info_df <- subset(mlst_df_clean, select = 1:4)
  
  #remove demogs column
  mlst_result_df <- subset(mlst_df_clean, , select = -c(1, 2, 3,4))


  #use first row data as column names in r
  colnames(mlst_result_df)=mlst_result_df[c(1),]

  #remove special characters and number from column header
  colnames(mlst_result_df) <- gsub("\\s*\\(.*", "", colnames(mlst_result_df))


  # Apply gsub to get text inside the parenthesis
  mlst_result_df <- apply(mlst_result_df, 2, function(x) gsub("\\(([^()]*)\\)|.", "\\1", x, perl=T))
  
  #remove rows with na value
  mlst_result_df <- mlst_result_df[ , colSums(is.na(mlst_result_df))==0]

  # Convert back to data frame
  mlst_result_df <- as.data.frame(mlst_result_df)

  #combine the two dataframe
  mlst_result_df <- cbind(mlst_info_df,mlst_result_df)
  
  #assign new name to dataframe
  nam <- paste("df", i, sep = "_")
  assign(nam, mlst_result_df[mlst_result_df$species==i,])
  
  mlst_df_list <- c(mlst_df_list, nam)
}


```



```{r mlst_table, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# List existing sample_id in the mlst table
not_included <- wgs_df$wgs_id[!(wgs_df$wgs_id %in% mlst_df_clean$wgs_id)]

# Iterate through the list of MLST dataframes
for(i in mlst_df_list) {
  df <- get(i)
  
  # Data cleanup
  df <- subset(df, select = -c(species))
  names(df)[names(df) == 'wgs_id'] <- 'species'
  
  # Define Legend
  mlst_legend <- HTML('<strong>Legend: </strong> <span style="font-style: italic;">(-) Not identified</span>')
  
  # Create the interactive table
  # We wrap it in a tagList and use knit_print to ensure it renders inside a loop
  tbl <- datatable(df,
    extensions = 'Buttons',
    rownames = FALSE,
    class = 'cell-border stripe',
    caption = tags$caption(style = 'caption-side: bottom; text-align: left;', mlst_legend),
    options = list(
      dom = 'lBfrtip',
      buttons = c('copy', 'csv', 'excel', 'print'),
      pageLength = 10,
      scrollX = TRUE,
      columnDefs = list(
        list(className = 'dt-center', targets = "_all"),
        list(targets = 1, fontStyle = 'italic'), # Italicize Species
        list(width = '150px', targets = 0),      # Width for Sample ID
        list(width = '150px', targets = 1)       # Width for Species
      ),
      initComplete = JS(
        "function(settings, json) {",
        "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
        "$(this.api().table().header()).find('th').css('text-align', 'center');",
        "}"
      )
    )
  )
  
  # In a loop with results='asis', we must print the HTML tag
  cat(as.character(htmltools::tagList(tbl)))
  cat("\n\n") # Add spacing between tables
}

```



```{r no_mlst_table, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# List existing sample_id not in the MLST table
no_mlst <- sample_name_clean[!(sample_name_clean %in% mlst_df_clean$sample_id)]

if (length(no_mlst) != 0) {
  sample_id <- paste(no_mlst, batch_name_clean, sep = "_")
  wgs_id <- wgs_df$wgs_id[(wgs_df$sample_id %in% sample_id)]
  sample_id_clean <- sub("(.*)_[^_]*$", "\\1", sample_id)
  species <- "No MLST result"
  
  # Create the dataframe
  df_no_mlst <- data.frame(sample_id_clean, wgs_id, species)
  colnames(df_no_mlst) <- c('Sample ID', 'WGS ID', 'Species/Remarks')
  
  # Render Interactive Table
  tbl_no_mlst <- datatable(df_no_mlst,
    extensions = 'Buttons',
    rownames = FALSE,
    class = 'cell-border stripe',
    options = list(
      dom = 'lBfrtip',
      buttons = c('copy', 'csv', 'excel'),
      pageLength = 10,
      scrollX = TRUE,
      columnDefs = list(
        list(className = 'dt-center', targets = "_all")
      ),
      initComplete = JS(
        "function(settings, json) {",
        "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
        "$(this.api().table().header()).find('th').css('text-align', 'center');",
        "}"
      )
    )
  )
  
  # Use tagList and cat for 'asis' rendering in a chunk
  cat(as.character(htmltools::tagList(tbl_no_mlst)))
}

```



### MLST RESULTS SUMMARY:
```{r mlst_summary, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
library(dplyr)
library(DT)
library(htmltools)

mlst_summary <- data.frame(Species=character(), 
                           MLST=character(), 
                           stringsAsFactors=FALSE) 

for(i in mlst_df_list) {
    df <- get(i)
    
    # Get unique species value
    species <- unique(df$wgs_id)
    
    # Remove from list all values with "quasi"
    species <- species[!species %in% grep("quasi", species, value = T)]

    # Summarize and count MLST results
    mlst_count_df <- df %>% 
      group_by(wgs_id, MLST) %>% 
      summarise(count = sum(!is.na(MLST)), .groups = 'drop')
    
    mlst_count_df$mlst_count <- paste0(mlst_count_df$MLST, " (n= ", mlst_count_df$count, " )")

    mlst_count_summary <- subset(mlst_count_df, select = c(wgs_id, mlst_count))
    
    mlst_summary_df <- mlst_count_summary %>% 
      group_by(wgs_id) %>% 
      mutate(mlst_count = paste0(mlst_count, collapse = ", ")) %>%
      distinct()
    
    mlst_summary <- rbind(mlst_summary, mlst_summary_df)
}

# --- Rename columns for the display table ---
colnames(mlst_summary) <- c("Species", "MLST Summary")

# --- Define Legend HTML ---
summary_legend <- HTML('<strong>Legend: </strong> <span style="font-style: italic;">(-) Not identified</span>')

# --- Generate Interactive Table ---
tbl_summary <- datatable(mlst_summary,
  extensions = 'Buttons',
  rownames = FALSE,
  class = 'cell-border stripe',
  caption = tags$caption(style = 'caption-side: bottom; text-align: left;', summary_legend),
  options = list(
    dom = 'lBfrtip',
    buttons = c('copy', 'csv', 'excel', 'print'),
    pageLength = 10,
    scrollX = TRUE,
    columnDefs = list(
      # Center alignment for the whole table or specific columns
      list(className = 'dt-center', targets = 1), 
      # Left alignment for Species for better readability
      list(className = 'dt-left', targets = 0),
      # Italicize Species column
      list(targets = 0, fontStyle = 'italic'),
      # Set width for the MLST summary column to handle long strings
      list(width = '600px', targets = 1)
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'background-color': '#D4D4D4', 'color': 'black'});",
      "$(this.api().table().header()).find('th').css('text-align', 'center');",
      "}"
    )
  )
)

# Render the table
cat(as.character(htmltools::tagList(tbl_summary)))

```




$\\$ $\\$ $\\$

### AMR PREDICTION RESULTS


```{r amr_genes ,echo=FALSE, message=FALSE, warning=FALSE}
df_amrfinderplus1 <- df_amrfinderplus

#checkm2 column names to lower
names(df_amrfinderplus1) <- tolower(names(df_amrfinderplus1))


#Change Name to sample_id
names(df_amrfinderplus1)[names(df_amrfinderplus1) == 'name'] <- 'sample_id'
names(df_amrfinderplus1)[names(df_amrfinderplus1) == 'element symbol'] <- 'element_symbol'

#change "-" to "_" in sample_id column
df_amrfinderplus1$sample_id <- gsub("-", "_", df_amrfinderplus1$sample_id, fixed=TRUE)


#merge wgs_id from wgs_df to mlst_df to set as species value
df_amrfinderplus1 <- merge(df_amrfinderplus1,wgs_species,by = "sample_id")

#remove "quasi" to wgs_id column
df_amrfinderplus1$wgs_id <- gsub("quasi", "", df_amrfinderplus1$wgs_id, fixed=TRUE)



# Filter rows where 'name' contains the word "sample"
df_amrfinderplus1 <- df_amrfinderplus1[grepl(batch_name_clean, df_amrfinderplus1$sample_id), ]

#remove batch name in sample_id
df_amrfinderplus1$sample_id <- sub("(.*)_[^_]*$", "\\1", df_amrfinderplus1$sample_id)

amr_genes_species <- unique(df_amrfinderplus1$wgs_id)

#vector to hold list of amr gene datables
amr_gene_df_list = c()


for(i in amr_genes_species) {
  df <- subset(df_amrfinderplus1, df_amrfinderplus1$wgs_id == i)
  sample_id <- c(df$sample_id)
  
  #create new dataframe to duplicate df_amrfinderplus1
  amr_genes_df <- df_amrfinderplus1
  
  #change "NA" to " " in subclass column
  amr_genes_df$subclass <- gsub("NA", "", amr_genes_df$subclass, fixed=TRUE)
  
  amr_genes_df$Newcols <- paste(amr_genes_df$type,amr_genes_df$subclass, sep = " ")
  
  #change "/" to "/ " in sample_id column
  amr_genes_df$Newcols <- gsub("/", "/ ", amr_genes_df$Newcols, fixed=TRUE)
  
  #subset dataframe to retain needed columns only
  amr_genes_df <- subset(amr_genes_df, select = c(sample_id,Newcols,element_symbol))
  
  
  #convert multiple rows with same Newcols value to single row
  amr_genes_df <- amr_genes_df %>%
    group_by(Newcols, sample_id) %>%
    summarize(Concat = paste0(element_symbol, collapse = ", "))
  
  #Create new dataframe to summarize the result
  amr_genes_df <- amr_genes_df  %>%
    pivot_wider(names_from = Newcols,
                values_from = Concat)
 #assign new name to dataframe
  nam <- paste("amr", i, sep = "_")
  assign(nam, amr_genes_df[amr_genes_df$sample_id %in% sample_id, ])
  
  amr_gene_df_list <- c(amr_gene_df_list, nam)

}


```


```{r amr_gene_tables, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
for(i in amr_gene_df_list) {
  df_orig <- get(i)
  
  wgs_species_1 <- wgs_species
  
  # Remove batch name in sample_id
  wgs_species_1$sample_id <- sub("(.*)_[^_]*$", "\\1", wgs_species_1$sample_id)

  # Merge wgs_id from wgs_df to amr_gene to set as species value
  df <- merge(df_orig, wgs_species_1, by = "sample_id")
  
  # Change wgs_id to species
  names(df)[names(df) == 'wgs_id'] <- 'species'
  
  # Reorder column
  df <- df %>% relocate(species, .after = sample_id)
  
  # Remove columns with all NA values
  df <- df[, colSums(is.na(df)) < nrow(df)]
  
  # Get unique species value for the header
  species_val <- unique(df$species)[1]
  
  # Subset dataframe to retain needed columns (removing species column as it goes in header)
  df_subset <- subset(df, select = -c(species))
  
  # --- Create Custom Header (equivalent to add_header_above) ---
  sketch <- htmltools::withTags(table(
    class = 'display',
    thead(
      tr(
        th(colspan = ncol(df_subset), 
           style = "text-align: left; font-style: italic; font-size: 18px; border-bottom: 1px solid #111;", 
           species_val)
      ),
      tr(
        lapply(colnames(df_subset), th, style = "text-align: center;")
      )
    )
  ))

  # --- Create the interactive table ---
  tbl <- datatable(df_subset,
    container = sketch,
    extensions = 'Buttons',
    rownames = FALSE,
    class = 'cell-border stripe',
    options = list(
      dom = 'lBfrtip',
      buttons = c('copy', 'csv', 'excel', 'print'),
      pageLength = 10,
      scrollX = TRUE, # Essential for tables with many gene columns
      columnDefs = list(
        list(className = 'dt-center', targets = "_all"),
        list(width = '200px', targets = "_all") # Prevents columns from being too cramped
      ),
      initComplete = JS(
        "function(settings, json) {",
        "$(this.api().table().header()).find('tr:eq(1) th').css({",
        "  'background-color': '#D4D4D4',",
        "  'color': 'black'",
        "});",
        "}"
      )
    )
  )
  
  # Output the HTML table
  cat(as.character(htmltools::tagList(tbl)))
  cat("\n\n\\vspace{8mm}\n\n")
}

```





